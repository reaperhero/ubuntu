# 事务隔离级别

如果没有事务隔离那么可能会出现脏读、不可重复读、幻读等情况

(1) 脏读：指在自己的事务中读到了别人未提交的数据

(2) 不可重复读：指在自己的事务中读取两次，前后的数据不一样【不可重复读的重点是修改】

(3) 幻读：指在自己的事务中两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果【读的重点在于新增或者删除】

想要避免以上的情况，我们可以通过设置数据库的隔离级别(结合实际场景选择最适合的级别)。一般数据库都包括以下四种隔离级别：

读未提交(Read Uncommitted)
读提交(Read Committed)
可重复读(Repeated Read)
串行化(Serializable)


MySQL中事务隔离级别分为以下四级：

0级：TRANSACTION_READ_UNCOMMITTED 一切都可发生
1级：TRANSACTION_READ_COMMITTED--不可以发生脏读，不可重复读和幻读可以发生
2级：TRANSACTION_REPEATABLE_READ--不可以发生脏读和重复读，可以发生幻读
3级：TRANSACTION_SERIALIZABLE --都不可发生

(1) 读未提交(TRANSACTION_READ_UNCOMMITTED)

读未提交，指可以读到未提交的内容。因为这种隔离级别下查询是不会加锁的，所以可能会产生“脏读”、“不可重复读”、“幻读”。在实际开发中如无特殊情况基本是不会使用该隔离级别的。

(2) 读提交(TRANSACTION_READ_COMMITTED)

读提交，指只能读到已经提交了的内容。这是最常用的一种隔离级别也是Oracle和SQLServer的默认级别，该级别可以有效地避免脏读。(注意：除非显示加锁如共享锁、排他锁，否则查询是默认不加锁的。而区别于“读未提交”，“读提交”可避免脏读的原因是采用了 “快照读”)

(3) 可重复读(TRANSACTION_REPEATABLE_READ)

可重复读，该级别可以有效的避免“不可重复读”，也是<b>MySQL数据库innodb默认的级别</b>。在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时就不允许进行Update操作，而“不可重复读”是因为两次读取之间进行了数据的修改所导致的。因此“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作”而产生的。

(4) 串行化(TRANSACTION_SERIALIZABLE)

串行化是数据库最高的隔离级别，这种级别下事务串行化一个一个排队顺序执行，可避免脏读、不可重复读、幻读。安全性高相应的执行效率低，性能开销也最大，在实际开发中比较少用