# 事务隔离级别

如果没有事务隔离那么可能会出现脏读、不可重复读、幻读等情况

(1) 脏读：指在自己的事务中读到了别人未提交的数据

(2) 不可重复读：指在自己的事务中读取两次，前后的数据不一样【不可重复读的重点是修改】

(3) 幻读：指在自己的事务中两个连续的查找之间一个并发的修改事务修改了查询的数据集，导致这两个查询返回了不同的结果【读的重点在于新增或者删除】

想要避免以上的情况，我们可以通过设置数据库的隔离级别(结合实际场景选择最适合的级别)。一般数据库都包括以下四种隔离级别：

读未提交(Read Uncommitted)
读提交(Read Committed)
可重复读(Repeated Read)
串行化(Serializable)


MySQL中事务隔离级别分为以下四级：

0级：TRANSACTION_READ_UNCOMMITTED 一切都可发生
1级：TRANSACTION_READ_COMMITTED--不可以发生脏读，不可重复读和幻读可以发生
2级：TRANSACTION_REPEATABLE_READ--不可以发生脏读和重复读，可以发生幻读
3级：TRANSACTION_SERIALIZABLE --都不可发生

(1) 读未提交(TRANSACTION_READ_UNCOMMITTED)

读未提交，指可以读到未提交的内容。因为这种隔离级别下查询是不会加锁的，所以可能会产生“脏读”、“不可重复读”、“幻读”。在实际开发中如无特殊情况基本是不会使用该隔离级别的。

(2) 读提交(TRANSACTION_READ_COMMITTED)

读提交，指只能读到已经提交了的内容。这是最常用的一种隔离级别也是Oracle和SQLServer的默认级别，该级别可以有效地避免脏读。(注意：除非显示加锁如共享锁、排他锁，否则查询是默认不加锁的。而区别于“读未提交”，“读提交”可避免脏读的原因是采用了 “快照读”)

(3) 可重复读(TRANSACTION_REPEATABLE_READ)

可重复读，该级别可以有效的避免“不可重复读”，也是<b>MySQL数据库innodb默认的级别</b>。在这个级别下，普通的查询同样是使用的“快照读”，但是，和“读提交”不同的是，当事务启动时就不允许进行Update操作，而“不可重复读”是因为两次读取之间进行了数据的修改所导致的。因此“可重复读”能够有效的避免“不可重复读”，但却避免不了“幻读”，因为幻读是由于“插入或者删除操作”而产生的。


针对快照读（普通查询语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
针对当前读（更新数据前的查询），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

(4) 串行化(TRANSACTION_SERIALIZABLE)

串行化是数据库最高的隔离级别，这种级别下事务串行化一个一个排队顺序执行，可避免脏读、不可重复读、幻读。安全性高相应的执行效率低，性能开销也最大，在实际开发中比较少用



# 数据库

DB_TRX_ID：最近修改（更新/删除/插入）该记录的事务ID。
DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本

up_limit_id：最先开始的事务，该SQL启动时，当前事务链表中最小的事务id编号，也就是当前系统中创建最早但还未提交的事务
low_limit_id：最后开始的事务，该SQL启动时，当前事务链表中最大的事务id编号，也就是最近创建的除自身以外最大事务编号
m_ids：当前活跃事务ID列表，所有事务链表中事务的id集合

首先比较这条记录的 DB_TRX_ID 是否是 小于 up_limit_id 或者 等于当前事务id。如果满足，那么说明当前事务能看到这条记录。如果大于则进入下一轮判断
然后判断这条记录的 DB_TRX_ID 是否 大于等于 low-limit-id。如果大于等于则说明此事务无法看见该条记录，不然就进入下一轮判断。
判断该条记录的 DB_TRX_ID 是否在活跃事务的数组中，如果在则说明这条记录还未提交对于当前操作的事务是不可见的，如果不在则说明已经提交，那么就是可见的。

