# RabbitMQ介绍

## 工作模式

- Work queues

两个消费端共同消费同一个队列中的消息，不用定义交换机

1. 一条消息只会被一个消费者接收；

2. rabbit采用轮询的方式将消息是平均发送给消费者的；

3. 消费者在处理完某条消息后，才会收到下一条消息


- Publish/Subscribe

每个消费者监听自己的队列，生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息
使用生产者发送若干条消息，每条消息都转发到各各队列，每消费者都接收到了消息

- Routing

1. 每个消费者监听自己的队列，并且设置routingkey。

2. 生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列

生产者发送若干条消息，交换机根据routingkey转发消息到指定的队列。


- Topics

1. 每个消费者监听自己的队列，并且设置带统配符的routingkey。

2. 生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。

生产者发送若干条消息，交换机根据routingkey统配符匹配并转发消息到指定的队列


- Header

​header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。

根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。


- RPC

RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下：

1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。

2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果

3、服务端将RPC方法 的结果发送到RPC响应队列

4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果


## 参数说明

- exchange的类型


```
direct 直连交换机 （直接交换模式／默认）
topic 主题交换机 模糊匹配 routingkey
①*（星号）仅代表一个单词
②#（井号）代表任意个单词
headers 首部交换机 headers与direct的模式不同，不是使用routingkey去做绑定。而是通过消息headers的键值对匹配
fanout 扇形交换机 已知的所有队列 相当于广播 速度最快 忽略routingkey
```

- 声明队列

队列一旦声明,参数将无法更改,添加,删除。改变一个队列的参数,只有两种办法: 1、删除该队列,重新创建; 2、换个名字,创建一个新的队列.

1. 生产者
```
channel.QueueDeclare
(
    queue: QueueName, //队列名称
    durable: false, //队列是否持久化.false:队列在内存中,服务器挂掉后,队列就没了;true:服务器重启后,队列将会重新生成.注意:只是队列持久化,不代表队列中的消息持久化!!!!
    exclusive: false, //队列是否专属,专属的范围针对的是连接,也就是说,一个连接下面的多个信道是可见的.对于其他连接是不可见的.连接断开后,该队列会被删除.注意,不是信道断开,是连接断开.并且,就算设置成了持久化,也会删除.
    autoDelete: true, //如果所有消费者都断开连接了,是否自动删除.如果还没有消费者从该队列获取过消息或者监听该队列,那么该队列不会删除.只有在有消费者从该队列获取过消息后,该队列才有可能自动删除(当所有消费者都断开连接,不管消息是否获取完)
    arguments: null //队列的配置
);


arguments

Message TTL : 消息生存期,一个队列中的消息,在被丢弃之前能够存活多少毫秒.( key 为 "x-message-ttl").通俗讲就是,队列中的消息的生存周期,单位毫秒.
Auto expire : 队列生存期,队列多长时间(毫秒)没有被使用(访问)就会被删除.换个说法就是,当队列在指定的时间内没有被使用(访问)就会被删除.
Max length : 队列可以容纳的消息的最大条数,队列可以容纳的消息的最大条数,超过这个条数,队列头部的消息将会被丢弃.
Max length bytes : 队列可以容纳的消息的最大字节数,队列可以容纳的消息的最大字节数,超过这个字节数,队列头部的消息将会被丢弃.
Overflow behaviour : 队列中的消息溢出后如何处理,队列中的消息溢出时,如何处理这些消息.要么丢弃队列头部的消息,要么拒绝接收后面生产者发送过来的所有消息。"drop-head" 是默认行为
Dead letter exchange : 溢出的消息需要发送到绑定该死信交换机的队列,该参数值为一个(死信)交换机的名称,当队列中的消息的生存期到了,或者因长度限制被丢弃时,消息会被推送到(绑定到)这台交换机(的队列中),而不是直接丢掉. 
Dead letter routing key : 溢出的消息需要发送到绑定该死信交换机,并且路由键匹配的队列
Maximum priority : 最大优先级,设置该队列中的消息的优先级最大值.发布消息的时候,可以指定消息的优先级,优先级高的先被消费.如果没有设置该参数,那么该队列不支持消息优先级功能.也就是说,就算发布消息的时候传入了优先级的值,也不会起什么作用.
Lazy mode : 懒人模式,设置队列为懒人模式.该模式下的队列会先将交换机推送过来的消息(尽可能多的)保存在磁盘上,以减少内存的占用.当消费者开始消费的时候才加载到内存中;如果没有设置懒人模式,队列则会直接利用内存缓存,以最快的速度传递消息
```
2. 消费者
```
autoAck: true //应答模式，true：自动应答，即消费者获取到消息，该消息就会从队列中删除掉，false：手动应答，当从队列中取出消息后，需要程序员手动调用方法应答，如果没有应答，该消息会一直存在队列中.
```


## 消息确认机制

### 生产者确认

对于不可路由的消息,broker 将在 exchange 验证消息不会路由到任何队列（发回一个空的队列列表）后发出确认;如果消息被设置为"必需消息"发布,即 BasicPublish() 方法的 "mandatory" 入参为true,那么 BasicReturn 事件将在 BasicAcks 事件之前触发.否定确认 BasicNacks 事件也是如此.

对于可路由消息,当所有队列都接受消息时才触发 BasicAcks 事件,对于路由到持久话队列的持久性消息,这意味着持久化到磁盘后才会触发 BasicAcks 事件;对于消息的镜像队列,这意味着所有镜像都已接受该消息后才会触发 BasicAcks 事件.

### 消费者确认
- 自动确认

在自动确认模式中,消息在发送到消费者后即被认为"成功消费".这种模式可以降低吞吐量（只要消费者可以跟上）,以降低交付和消费者处理的安全性.这种模式通常被称为“即发即忘”.与手动确认模型不同,如果消费者的TCP连接或通道在真正的"成功消费"之前关闭,则服务器发送的消息将丢失.因此,自动消息确认应被视为不安全,并不适用于所有工作负载.

- 手动确认

1. 肯定确认

当消费者收到一条消息,但是还没有肯定确认时,从管理后台可以清晰的看到,队列中一共有5条消息,其中4条尚未推送,1条已经推送但尚未确认.

当消费者确认后(立马又接收了一条),这时候,队列中一共只有4条了,"成功消费"的那条已经被broker从队列中删掉了.剩余3条尚未推送,1条已推送但尚未确认.

2. 否定确认

否定确认的场景不多,但有时候某个消费者因为某种原因无法立即处理某条消息时,就需要否定确认了.

否定确认时,需要指定是丢弃掉这条消息,还是让这条消息重新排队,过一会再来,又或者是让这条消息重新排队,并尽快让另一个消费者接收并处理它

