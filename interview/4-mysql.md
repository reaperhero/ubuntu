


如何判断一条SQL语句是否使用了索引？

使用 EXPLAIN 命令分析SQL执行计划。查看结果中的 key 字段，如果显示了索引名称，则表示使用了索引。同时 type 字段的值也能反映索引使用情况（如const, ref, range等表示使用了索引）。


MySQL索引的原理（B+Tree）？

B树的核心特性：

多路（M-way）： 一个节点可以有多个子节点（远超2个），这大大降低了树的高度。

平衡（Balanced）： 所有叶子节点都位于同一层。这保证了查询效率的稳定。

有序： 节点内的键（Key）是按顺序存放的，采用二分查找提升节点内搜索效率


什么是回表？什么是覆盖索引？


MySQL的默认隔离级别是什么？它是如何解决幻读的？

默认隔离级别：可重复读 (Repeatable Read)。

解决幻读的机制：

MVCC (多版本并发控制)：为每个事务提供一个一致性的数据快照。

Next-Key Locks (临键锁)：InnoDB通过行锁 + 间隙锁 (Gap Lock) 的组合，锁住一个记录及其周围的间隙，防止其他事务在范围内插入新数据，从而解决了幻读问题。




MySQL主从复制原理
整个过程分为三步：主库将数据变更写入Binlog；从库的I/O线程将主库的Binlog读取并写入到本地的Relay Log；从库的SQL线程重放Relay Log中的事件。


索引
“从逻辑功能上创建，我们可以创建普通索引、唯一索引、主键索引、联合索引等。设计联合索引时要特别注意最左前缀原则。




4. 请描述在B树中插入一个键（Key）的大致过程。

步骤：

查找位置： 从根节点开始，找到键应该被插入的叶子节点。

插入叶子： 将新键按顺序插入到这个叶子节点中。

检查分裂：

如果插入后，该叶子节点的键数量未超过 M-1，则插入结束。

如果超过了 M-1，则需要进行节点分裂。

节点分裂：

将该节点的键分成三部分：左半部分、中间键、右半部分。

创建一个新节点，将右半部分的键移入新节点。

将中间键提升到父节点中，并建立新节点与父节点的指针链接。

递归向上： 如果父节点因为提升了一个键也导致溢出，则对父节点递归执行分裂过程。这个过程可能一直传递到根节点。如果根节点分裂，树高就会增加。

5. 请描述在B树中删除一个键的大致过程。

删除比插入更复杂，核心思想是“合并”以保证平衡。

查找位置： 找到包含要删除键的节点。

情况1：在叶子节点中删除

直接删除： 如果删除后，该叶子节点的键数量仍然 >= ceil(M/2)-1，则直接删除，结束。

需要调整： 如果删除后，键数量小于最小值（下溢），则需要向兄弟节点借一个键，或者与兄弟节点合并。

情况2：在非叶子节点中删除

通常不会直接删除。会找到该键的前驱（左子树中最大的键）或后继（右子树中最小的键），用这个前驱或后继的值覆盖要删除的键，然后转而删除那个前驱或后继。这保证了被删除的键总是在叶子节点上。

调整下溢：

借键： 如果相邻的兄弟节点有富余（键数 > ceil(M/2)-1），则从父节点借一个键下来，再从兄弟节点拿一个键上去填补父节点。

合并： 如果兄弟节点也没有富余，则将父节点中对应的键拉下来，与当前节点和兄弟节点合并成一个新节点。这可能导致父节点下溢，需要递归向上进行调整。





这是B树面试的终极问题，考察对两者差异在数据库场景下的理解。

更低的树高，更少的I/O： B+树的非叶子节点不存储数据，只存储键和指针。这意味着一个节点可以容纳更多的键，从而使整棵树更加“矮胖”，进一步减少了磁盘I/O次数。

更稳定的查询性能： B+树的所有查询都必须从根节点走到叶子节点，路径长度完全相同，性能稳定。而B树的查询可能在内部节点就结束，性能不稳定。

极强的范围查询能力： B+树的叶子节点通过指针相连，形成了一个有序链表。一旦定位到范围查询的起始点，只需顺序遍历链表即可，效率极高。而B树进行范围查询需要进行复杂的中序遍历。

更好的空间局部性： 由于叶子节点存储了所有数据，并且是连续存储的，数据库预读特性（Preloading）可以更有效地加载多个连续的数据页到内存，进一步提升全表扫描和范围查询的效率。


B树/B+树的一个节点大小通常是如何设定的？为什么？

答案： 通常设置为等于磁盘页的大小（如4KB, 16KB）。

原因： 磁盘读写是以页为基本单位的。即使只读一个字节，也会读取整个页。将B树节点大小设置为页大小的整数倍，可以确保一次磁盘I/O操作就能完全加载一个节点到内存中，最大限度地利用每次I/O，这是B树设计用来减少磁盘I/O的关键假设之一