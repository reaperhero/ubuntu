1. 两数之和 (Two Sum)
题目：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
示例：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]

思路：使用哈希表（在 Go 中是 map）来存储遍历过的数字及其索引。对于每个数字 num，计算其补数 complement = target - num。如果补数已经在 map 中，则直接返回结果。否则，将当前数字和索引存入 map。

func twoSum(nums []int, target int) []int {
    numMap := make(map[int]int) // key: number, value: index
    for i, num := range nums {
        complement := target - num
        if idx, found := numMap[complement]; found {
            return []int{idx, i}
        }
        numMap[num] = i
    }
    return nil // 题目保证有解，这里返回 nil 以防万一
}



2. 反转链表 (Reverse Linked List)
题目：给你单链表的头节点 head，请你反转链表，并返回反转后的链表。

思路：迭代法。使用三个指针：prev, curr, next。遍历链表，将当前节点 curr 的 Next 指针指向前一个节点 prev，然后三个指针整体前移。

go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode = nil
    curr := head

    for curr != nil {
        nextTemp := curr.Next // 暂存下一个节点
        curr.Next = prev      // 反转当前节点的指针
        prev = curr           // prev 前移
        curr = nextTemp       // curr 前移
    }
    return prev // prev 最终成为新的头节点
}


3. 合并两个有序链表 (Merge Two Sorted Lists)
题目：将两个升序链表合并为一个新的 升序 链表并返回。

思路：递归或迭代。迭代法更节省空间。创建一个哨兵节点（Dummy Node）简化边界条件处理。比较两个链表当前节点的值，将较小的节点连接到新链表上。

go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{} // 哨兵节点
    tail := dummy

    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            tail.Next = list1
            list1 = list1.Next
        } else {
            tail.Next = list2
            list2 = list2.Next
        }
        tail = tail.Next
    }
    // 将剩余的非空链表直接接上去
    if list1 != nil {
        tail.Next = list1
    } else {
        tail.Next = list2
    }
    return dummy.Next
}


4. 二叉树遍历
深度优先搜索 (DFS) ：前后中 序遍历 
广度优先搜索 (BFS) - 层序遍历
题目：给定一个二叉树的根节点 root，返回它的 中序 遍历。
示例：
输入：root = [1,null,2,3]
输出：[1,3,2]

前序遍历 (Preorder Traversal)
顺序：根 -> 左 -> 右
func preorderTraversal(root *TreeNode) []int {
    var result []int
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        result = append(result, node.Val) // 先访问根
        dfs(node.Left)                    // 再左子树
        dfs(node.Right)                   // 最后右子树
    }
    dfs(root)
    return result
}
迭代实现（使用栈）
func preorderTraversal(root *TreeNode) []int {
    var result []int
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) > 0 {
        // 不断访问当前节点并转向左子树
        for curr != nil {
            result = append(result, curr.Val) // 访问根
            stack = append(stack, curr)       // 入栈
            curr = curr.Left                  // 转向左
        }
        // 弹出栈顶，转向右子树
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        curr = curr.Right
    }
    return result
}


中序遍历 (Inorder Traversal)
顺序：左 -> 根 -> 右
递归实现：

func inorderTraversal(root *TreeNode) []int {
    var result []int
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)                    // 先左子树
        result = append(result, node.Val) // 再访问根
        dfs(node.Right)                   // 最后右子树
    }
    dfs(root)
    return result
}
迭代实现（经典栈方法）：
func inorderTraversal(root *TreeNode) []int {
    var result []int
    stack := []*TreeNode{}
    curr := root

    for curr != nil || len(stack) > 0 {
        // 不断将左子节点入栈
        for curr != nil {
            stack = append(stack, curr)
            curr = curr.Left
        }
        // 弹出栈顶并访问
        curr = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, curr.Val)
        // 转向右子树
        curr = curr.Right
    }
    return result
}

后序遍历 (Postorder Traversal)
顺序：左 -> 右 -> 根

递归实现：

func postorderTraversal(root *TreeNode) []int {
    var result []int
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)                    // 先左子树
        dfs(node.Right)                   // 再右子树
        result = append(result, node.Val) // 最后访问根
    }
    dfs(root)
    return result
}

迭代实现（技巧性较强）：
func postorderTraversal(root *TreeNode) []int {
    if root == nil {
        return nil
    }
    var result []int
    stack := []*TreeNode{root}
    
    for len(stack) > 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        result = append(result, node.Val) // 头插法，最后反转
        
        // 注意入栈顺序：先左后右
        if node.Left != nil {
            stack = append(stack, node.Left)
        }
        if node.Right != nil {
            stack = append(stack, node.Right)
        }
    }
    // 反转结果（因为用的是头插法）
    for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
        result[i], result[j] = result[j], result[i]
    }
    return result
}

层序遍历 (Level Order Traversal)
按层次从上到下遍历
func levelOrder(root *TreeNode) [][]int {
    if root == nil {
        return [][]int{}
    }
    
    var result [][]int
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        levelSize := len(queue)
        currentLevel := make([]int, levelSize)
        
        for i := 0; i < levelSize; i++ {
            node := queue[0]
            queue = queue[1:]
            currentLevel[i] = node.Val
            
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        result = append(result, currentLevel)
    }
    return result
}



数组
特性：在内存中连续存储，通过索引（下标）直接访问元素，效率极高（O(1)）。但大小通常固定（静态数组），插入和删除元素（尤其是在中间）效率低（O(n)），因为需要移动后续所有元素

链表
特性：元素（节点）在内存中非连续存储，通过指针连接。插入和删除节点效率高（O(1)），只需修改指针。但随机访问效率低（O(n)），需要从头遍历。

栈
特性：后进先出（LIFO）的线性结构。只允许在一端（栈顶）进行插入（压栈）和删除（弹栈）操作。

队列
特性：先进先出（FIFO）的线性结构。在一端（队尾）添加元素，在另一端（队首）移除元素。

哈希表
特性：通过键（Key）直接访问值（Value）的数据结构。其核心是哈希函数，它将键映射到数组的特定位置，从而实现近乎 O(1) 的平均查找、插入和删除效率。但哈希冲突可能会影响性能。

树
特性：层次化的非线性结构。每个节点有一个父节点（根节点除外）和零个或多个子节点

二叉树
二叉搜索树：左子树所有节点的值小于根节点，右子树所有节点的值大于根节点。其中序遍历是有序序列。
平衡二叉搜索树（如AVL树、红黑树）：通过自平衡操作确保树的高度保持 O(log n)，从而保证最坏情况下也有高效的操作。


图
特性：由顶点和边组成的结构，用于表示实体（顶点）之间的关系（边）。

1. 平衡二叉树
平衡二叉树是一种自平衡的二叉搜索树，其中任何节点的两个子树的高度差（平衡因子）绝对值不超过1。
平衡因子（Balance Factor）：BF = height(left) - height(right)
|BF| ≤ 1：平衡
|BF| > 1：不平衡，需要旋转

与红黑树区别
特性	    平衡二叉树 (AVL树)	                                       红黑树 (Red-Black Tree)
平衡标准	严格平衡。每个节点的左右子树高度差（平衡因子）绝对值不超过 1。    | 	近似平衡。确保没有一条路径会比其他路径长出一倍以上。
查找性能	更高。由于树的高度始终保持在极限平衡状态，查找操作（Search）非常快。对于查找密集型任务，AVL树是更好的选择。	| 良好。由于树的高度比AVL树稍高（在相同节点数下），查找速度通常略慢于AVL树。
插入/删除性能	较低。为了维持严格的平衡，插入和删除操作可能需要更多的旋转（通常是O(1)或O(log n)次旋转）。| 	更高。插入和删除操作通常需要更少的旋转（最多3次旋转即可重新平衡）。效率更高。
重新平衡操作	通过旋转（左旋、右旋）来调整平衡。	|  通过旋转（左旋、右旋）和节点颜色变换（变色）来调整平衡。
数据结构	通常每个节点存储：值、左右子节点指针、高度（或平衡因子）。 | 	通常每个节点存储：值、左右子节点指针、父节点指针（便于向上回溯）、颜色（红或黑）。
使用场景	适用于搜索操作非常频繁，而插入和删除操作相对较少的场景。例如：数据库索引、字典等。| 	适用于插入和删除操作频繁，且查找操作也存在的场景。它是综合性能的优胜者。

为什么红黑树更常用？
尽管AVL树拥有更快的查找速度，但在实际应用中，红黑树的使用范围远大于AVL树。主要原因如下：

综合性能更优：在计算机科学的大多数应用中（如数据结构库、文件系统、数据库等），插入和删除操作是非常常见的。红黑树在插入和删除上的更高效率带来了更好的整体性能。

更少的旋转开销：更少的旋转意味着在频繁修改数据时，红黑树的性能开销更小。

成熟的实现：正是由于其优越的综合性能，红黑树被广泛采用并集成到各种语言和系统的标准库中，形成了良性循环。