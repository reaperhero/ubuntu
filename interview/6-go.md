

5. 值接收者和指针接收者的区别？
在方法定义中，可以为接收者选择值类型或指针类型。

特性	值接收者 (func (u User) Method())	指针接收者 (func (u *User) Method())
操作对象	接收者的一个副本	接收者本身的指针
修改影响	对副本的修改不会影响原对象	通过指针的修改会影响原对象
调用方式	值和指针都可以调用（Go 自动解引用）	值和指针都可以调用（Go 自动取地址）
适用场景	不需要修改接收者、操作小结构体	需要修改接收者、操作大结构体（避免拷贝开销）
一般原则： 如果不确定，使用指针接收者


2. Channel 是什么？有缓冲和无缓冲的区别？
Channel： 是 Goroutine 之间进行通信和同步的管道。遵循“不要通过共享内存来通信，而应该通过通信来共享内存”的原则。

无缓冲 Channel (make(chan T))：

发送和接收操作是同步的（阻塞的）。

发送方在接收方准备好接收之前会一直阻塞，反之亦然。它保证了通信双方在那一刻的同步。

有缓冲 Channel (make(chan T, size))：

发送操作在缓冲区未满时是异步的（不阻塞），只有在缓冲区满时才阻塞。

接收操作在缓冲区非空时是异步的，只有在缓冲区空时才阻塞。

它更像一个消息队列，解耦了发送和接收的时序。



3. select 语句有什么作用？
select 语句用于监听多个 channel 的读写操作，类似于 switch，但每个 case 必须是一个 channel 操作。

它会阻塞，直到某个 case 可以执行。

如果多个 case 同时就绪，它会随机公平地选择一个执行。

可以有 default 分支，用于实现非阻塞的 channel 操作


切片（Slice）的底层原理和扩容机制？

底层结构： 包含一个指向底层数组的指针、长度（len）和容量（cap）。

扩容机制： 使用 append 超出现有容量时触发。

如果新容量 > 2*旧容量，则直接使用新容量。

否则，如果旧切片长度 < 1024，则新容量翻倍。

如果旧切片长度 >= 1024，则每次增加 25%。

最后计算的内存大小会进行内存对齐。

Map 是否是线程安全的？如何安全使用？

不是线程安全的。并发读写会触发 panic。

安全使用：

使用 sync.RWMutex（读写锁，适合读多写少）。

使用 sync.Map（官方提供的并发 map，适用于特定场景，如 key 稳定、写多读少）



go defer 执行


1、channel是不是线程安全的，
2、channel关闭的原则是什么，在一个发送，多个接收的场景，多个发送和多个接收
3、关闭 Channel - close(ch)
获取锁。
设置 closed = 1。

遍历 recvq 队列，将所有等待接收的 goroutine 唤醒，并给它们返回一个零值和 false（表示通道已关闭）。

遍历 sendq 队列，将所有等待发送的 goroutine 唤醒，这些 goroutine 会触发 panic（因为不能向已关闭的 channel 发送数据）。

释放锁。


go pprof 怎么分析程序异常

1、利用channel，循环打印ABC 50次



2. 简述 Go 的垃圾回收（GC）机制
Go 目前使用的是并发标记清除（Concurrent Mark and Sweep, CMS） 算法，并在此基础上引入了三色标记法和写屏障（Write Barrier） 来实现并发性。

三色抽象：

黑色： 对象已被扫描，它引用的对象也都被扫描了。

灰色： 对象已被扫描，但它引用的对象还未被扫描。

白色： 对象尚未被扫描（最终会被回收）。

过程：

标记准备（Mark Setup）： STW（Stop The World），非常短。

并发标记（Concurrent Marking）： 与用户程序并发执行，遍历对象图进行标记。

标记终止（Mark Termination）： 一个短暂的 STW，完成标记工作。

并发清除（Concurrent Sweeping）： 与用户程序并发执行，回收白色对象的内存。

目标： 极大地减少 STW 的时间，通常控制在毫秒甚至微秒级别